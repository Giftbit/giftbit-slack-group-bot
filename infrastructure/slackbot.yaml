AWSTemplateFormatVersion: 2010-09-09
Description: Deployment of the SlackBot

Parameters:
  GroupBotProject:
    Type: String
    Description: The Group Bot Project Name. This will prefix the component functions.
  Accounts:
    Type: String
    Description: JSON Object of Account Name to Account ID Pairs
  SlackToken:
    Type: String
    Description: The Slack Token that should be used to authenticate incoming requests
    NoEcho: true

Resources:
  S3DataStore:
    Type: AWS::S3::Bucket
  SlackBotBackgroundFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code: ../dist/slackBotBackground/slackBotBackground.zip
      Handler: index.handler
      Runtime: nodejs6.10
      Timeout: 30
      Role: !GetAtt SlackBotBackgroundRole.Arn
      Environment:
        Variables:
          GROUP_BOT_PROJECT: !Ref GroupBotProject
          REGION: !Ref AWS::Region
  SlackBotBackgroundRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${GroupBotProject}-SlackBotBackgroundRole"
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          -
            Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
  SlackBotGroupListerInvokeAccess:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt SlackBotBackgroundFunction.Arn
      Principal: !GetAtt SlackBotRole.Arn
  SlackBotFunction:
    Type: AWS::Lambda::Function
    Properties:
      Code: ../dist/slackBot/slackBot.zip
      Handler: index.handler
      Runtime: nodejs6.10
      Timeout: 30
      Role: !GetAtt SlackBotRole.Arn
      Environment:
        Variables:
          ACCOUNTS: !Ref Accounts
          TOKEN: !Ref SlackToken
          GROUP_BOT_PROJECT: !Ref GroupBotProject
          REGION: !Ref AWS::Region
          SLACK_BOT_BACKGROUND_TASK_LAMBDA_ARN: !GetAtt SlackBotBackgroundFunction.Arn
  SlackBotRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub "${GroupBotProject}-SlackBotRole"
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          -
            Effect: Allow
            Action:
              - sts:AssumeRole
            Principal:
              Service:
                - lambda.amazonaws.com
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        -
          PolicyName: SlackBotAccess
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              -
                Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:ListBucket
                  - s3:DeleteObject
                Resource:
                  - !Sub "arn:aws:s3:::${S3DataStore}"
                  - !Sub "arn:aws:s3:::${S3DataStore}/*"
  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Body:
        info:
          version: 1.0
          title: !Ref 'AWS::StackName'
        paths:
          /webhook:
            post:
              responses:
                "200":
                  description: 200 response
              x-amazon-apigateway-integration:
                httpMethod: POST
                type: aws
                uri: !Sub "arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${SlackBotFunction.Arn}/invocations"
                responses:
                  default:
                    statusCode: 200
                    responseTemplates:
                      application/json: ""
                requestTemplates:
                  application/x-www-form-urlencoded: |-
                    ## From https://gist.github.com/199911/68a43f83fd933b1e3ac6
                    ## convert HTML POST data or HTTP GET query string to JSON

                    ## get the raw post data from the AWS built-in variable and give it a nicer name
                    #if ($context.httpMethod == "POST")
                     #set($rawAPIData = $input.path("$"))
                    #elseif ($context.httpMethod == "GET")
                     #set($rawAPIData = $input.params().querystring)
                     #set($rawAPIData = $rawAPIData.toString())
                     #set($rawAPIDataLength = $rawAPIData.length() - 1)
                     #set($rawAPIData = $rawAPIData.substring(1, $rawAPIDataLength))
                     #set($rawAPIData = $rawAPIData.replace(", ", "&"))
                    #else
                     #set($rawAPIData = "")
                    #end

                    ## first we get the number of "&" in the string, this tells us if there is more than one key value pair
                    #set($countAmpersands = $rawAPIData.length() - $rawAPIData.replace("&", "").length())

                    ## if there are no "&" at all then we have only one key value pair.
                    ## we append an ampersand to the string so that we can tokenise it the same way as multiple kv pairs.
                    ## the "empty" kv pair to the right of the ampersand will be ignored anyway.
                    #if ($countAmpersands == 0)
                     #set($rawPostData = $rawAPIData + "&")
                    #end

                    ## now we tokenise using the ampersand(s)
                    #set($tokenisedAmpersand = $rawAPIData.split("&"))

                    ## we set up a variable to hold the valid key value pairs
                    #set($tokenisedEquals = [])

                    ## now we set up a loop to find the valid key value pairs, which must contain only one "="
                    #foreach( $kvPair in $tokenisedAmpersand )
                     #set($countEquals = $kvPair.length() - $kvPair.replace("=", "").length())
                     #if ($countEquals == 1)
                      #set($kvTokenised = $kvPair.split("="))
                      #if ($kvTokenised[0].length() > 0)
                       ## we found a valid key value pair. add it to the list.
                       #set($devNull = $tokenisedEquals.add($kvPair))
                      #end
                     #end
                    #end

                    ## next we set up our loop inside the output structure "{" and "}"
                    {
                    #foreach( $kvPair in $tokenisedEquals )
                      ## finally we output the JSON for this pair and append a comma if this isn't the last pair
                      #set($kvTokenised = $kvPair.split("="))
                     "$util.urlDecode($kvTokenised[0])" : #if($kvTokenised[1].length() > 0)"$util.urlDecode($kvTokenised[1])"#{else}""#end#if( $foreach.hasNext ),#end
                    #end
                    }
        swagger: 2.0
  SlackBotFunctionRestApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:invokeFunction
      Principal: apigateway.amazonaws.com
      FunctionName: !Ref SlackBotFunction
      SourceArn: !Sub "arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${RestApi}/*/*/*"
  Deployment:
    Type: AWS::ApiGateway::Deployment
    Properties:
      RestApiId: !Ref RestApi
      StageName: Prod
  AccountDependencies:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: ./account-res.yaml
      Parameters:
        GroupBotProject: !Ref GroupBotProject
        GroupBotSlackHandlerAccount: !Ref AWS::AccountId
